#include <iostream>
#include <fstream>
#include <windows.h>
#include <conio.h>

#define MAXEXAM 5

#define BoxX 12
#define BoxY 6
#define BoxS 54
#define BoxW 10

using namespace std;

struct NODEMEAN {
	string data;
	NODEMEAN *Next;
};

struct Word {
	string This;
	string Type;
	char *Exam[MAXEXAM];
	NODEMEAN *First;
};

struct NODEWORD {
	Word data;
	NODEWORD *Left;
	NODEWORD *Right;
};

struct HTable 
{
	NODEWORD *Head;
	NODEWORD *Tail;
};

int Address(string Word) 
{
	return Word[0] - 97;
}

bool updated = false;

void Add_Mean_Head(NODEMEAN *&First, string Mean) 
{
	NODEMEAN *p = new NODEMEAN();
	p->data = Mean;
	p->Next = NULL;
	
	if (First == NULL) 
	{
		First = p;
	}
	else 
	{	
		p->Next = First;
		First = p;
	}
}

void AddTail(HTable *&Dict, NODEWORD *p) 
{
	int i = Address(p->data.This);
	
	if (Dict[i].Head == NULL) 
	{
		Dict[i].Head = Dict[i].Tail = p;
	}
	else 
	{
		Dict[i].Tail->Right = p;
		p->Left = Dict[i].Tail;
		Dict[i].Tail = p;
	}
}


NODEWORD* SplitInfo(string Line) 
{
	
	NODEWORD *p = new NODEWORD();
	
	int i, pos;
	i = 0;
	
	string Text = "";
	while (Line[i] != '/') 
	{
		Text += Line[i++];
	}
	p->data.This = Text;
	
	i++;
	Text = "";
	while (Line[i] != '/') 
	{
		Text += Line[i++];
	}
	p->data.Type = Text;
	
	i++;
	p->data.First = NULL;
	Text = "";
	while (Line[i] != '/') 
	{
		Text += Line[i++];
		if (Line[i] == ';') 
		{
			Add_Mean_Head(p->data.First, Text);
			Text = "";
			i++;	
		}
	}
	
	i++;
	Text = ""; 
	pos = 0;
	while (Line[i] != '/') 
	{
		Text += Line[i++];
		if (Line[i] == ';') 
		{ 
			p->data.Exam[pos++] = (char*)Text.c_str();
			Text = "";
			i++; 
		}
	}	
		
	return p;
}

void ReadFile(HTable *&Dict) {
	ifstream File("words.txt");
	string Line;
	
	if (File.is_open()) 
	{
		while (getline(File, Line)) 
		{
			NODEWORD *p = SplitInfo(Line);
			AddTail(Dict, p);
		}
		File.close(); 
	}
}

void gotoxy(short x, short y) {
	HANDLE hConsoleOutput;
	COORD Cursor_an_Pos = { x, y };
	hConsoleOutput = GetStdHandle(STD_OUTPUT_HANDLE);
	SetConsoleCursorPosition(hConsoleOutput, Cursor_an_Pos);
}

void DictBox()
{
	gotoxy(BoxX, BoxY);
	cout << char(201);

	for (int i = 1; i < BoxS + 1; i++)	cout << char(205);

	cout << char(187);

	gotoxy(BoxX, BoxY + 1);
	cout << char(186) << " Search: ";

	gotoxy(BoxX + BoxS + 1, BoxY + 1);
	cout << char(186);

	gotoxy(BoxX, BoxY + 2);
	cout << char(204);

	for (int i = 1; i < BoxS + 1; i++)	cout << char(205);

	cout << char(185);

	for (int i = 0; i < BoxW; i++)
	{
		gotoxy(BoxX, i + BoxY + 3);
		cout << char(186);
		gotoxy(BoxX + BoxS + 1, i + BoxY + 3);
		cout << char(186);
	}

	gotoxy(BoxX, BoxY + BoxW + 3);
	cout << char(200);

	for (int i = 1; i < BoxS + 1; i++)	cout << char(205);

	cout << char(188);
}

void Command_Menu(void)
{
	gotoxy(12, 2);
	cout << "Tab: Add new !";
	gotoxy(12, 3);
	cout << "Esc: Exit !";
}

bool Confirm(int &Input)
{
	system("cls");
	gotoxy(BoxX, BoxY);
	cout << "ESC again to exit the program";
	gotoxy(BoxX, BoxY + 1);
	cout << "Press any key to return to the program";
	Input = getch();
	if (Input != 27)
	{
		if (Input == 224)
			Input = _getch();
		Input = 0;
		return false;
	}
	return true;
	system("cls");
}

NODEWORD *Right(HTable *Dict, NODEWORD *Curr)
{
	if (Curr != NULL)
	{
		NODEWORD *RightWord = Curr->Right;
		if (RightWord != NULL)
		{
			return Curr->Right;
		}
		else
		{
			short x = Address(Curr->data.This);
			if (x < 25)
			{
				while (x != 25)
				{
					if (Dict[x + 1].Head != NULL)
					{
						return Dict[x + 1].Head;
					}
					x++;
				}
				return NULL;
			}

			return NULL;
		}
	}
	return NULL;
}

void DeleteBox(void)
{
	for (int i = 0; i < BoxW; i++)
	{
		gotoxy(BoxX + 1, BoxY + 3 + i);
		for (int j = 0; j < BoxS; j++)	cout << " ";
	}
}

void PrintCurrentLine(NODEWORD *Curr)
{
	if (Curr != NULL)
	{
		cout << " " << Curr->data.This;	//" " to mau
		for (int j = Curr->data.This.length(); j < BoxS - 1; j++)	cout << " ";	//To mau phan con lai
	}
}

void PrintSearchLine(NODEWORD *Word)
{
	if (Word != NULL)
		cout << Word->data.This;
}

void DisplayWord(HTable *Dict, NODEWORD *Curr)
{
	DeleteBox();
	if (Curr != NULL)
	{
		for (int i = 0; i < BoxW; i++)
		{
			if (i == 0)
			{
				gotoxy(BoxX + 1, BoxY + 3 + i);	//Di den dong dau tien 
				PrintCurrentLine(Curr);
			}
			else
			{
				gotoxy(BoxX + 2, BoxY + 3 + i);
				PrintSearchLine(Curr);
			}
			Curr = Right(Dict, Curr);
		}
	}
}

string FixText(string Text)
{
	if (Text != "")
	{
		while (Text[0] == ' ') Text.erase(0, 1);		//Xoa khoang trang
		while (Text[Text.length() - 1] == ' ')	Text.erase(Text.length() - 1, 1);
		if (Text.length() > 3)
		for (int i = 1; i < Text.length() - 2; i++)
		if (Text[i] == ' ' && Text[i + 1] == ' ')
		{
			Text.erase(i, 1);
			i--;
		}

		for (int i = 0; i < Text.length(); i++)			//Chuyen ve chu thuong
		if (Text[i]>'A' && Text[i] < 'Z')
			Text[i] += 32;
		return Text;
	}
	else
		return Text;
}

bool Compare(string Find, NODEWORD *Run)
{
	string x = Find, y = Run->data.This;
	if (x.length() > y.length())
		return false;
	else
	{
		for (int i = 0; i < x.length(); i++)
		if (x[i] != y[i])
			return false;
		return true;
	}
}

NODEWORD *Search(HTable *Dict, string Word)
{
	int x = Address(Word);
	if (x < 0)
		return NULL;
	else
	{
		NODEWORD *Head = Dict[x].Head;
		while (Head != NULL)
		{
			if (Compare(Word, Head))
				return Head;
			Head = Head->Right;
		}
		return NULL;
	}
}

void FindFirst(HTable *Dict, NODEWORD *&Curr)
{
	for (int i = 0; i < 26; i++)
	if (Dict[i].Head != NULL)
	{
		Curr = Dict[i].Head;
		break;
	}
}

NODEWORD *Left(HTable *Dict, NODEWORD *Curr)
{
	if (Curr != NULL)
	{
		NODEWORD *LeftWord = Curr->Left;
		if (LeftWord != NULL)
			return LeftWord;
		else
		{
			int x = Address(Curr->data.This);
			if (x > 0)
			{
				while (x > 0)
				{
					if (Dict[x - 1].Tail != NULL)
						return Dict[x - 1].Tail;
					x--;
				}
				return NULL;
			}
			return NULL;
		}
	}
	return NULL;
}

void SearchBox(HTable *&Dict, NODEWORD *&Curr)
{
	int Input = 0;
	bool changed = false;
	string Text = "";
	int Count = 0;
	while(1)
	{
		DictBox();
		Command_Menu();
		
		gotoxy(BoxX + 12, BoxY + 1);
		
		if (Count < BoxS - 12)	cout << Text;
		else	for (int i = Count - (BoxS - 12); i< Count; i++)	cout << Text[i];
		
		if (changed)
		{
			if (FixText(Text) != "")
				Curr = Search(Dict, FixText(Text));
			else	FindFirst(Dict, Curr);
			//	cout<"Ahihi";
		}
		
		DisplayWord(Dict,Curr);
		
		if (Count < BoxS - 12)	gotoxy(BoxX + 12 + Count, BoxY + 1);
		else gotoxy(BoxX + BoxS, BoxY + 1);
			
		Input = getch();
		switch(Input)
		{
			case 13:	//Enter
			{
			
				break;
			}
		
			case 8:		//Backspace
			{
				if (Count>0)
				{
					Count--;
					Text = Text.substr(0, Text.size() - 1);
					gotoxy(BoxX + 12, BoxY + 1);
					if (Count < BoxS - 12)
					{
						cout << Text;
						for (int i = BoxX + 11; i < BoxS; i++)	cout << " ";
					}
					else
					{
						for (int i = Count - 5; i<Count; i++)	cout << Text[i];
					}
				}
				break;
			}
		
			case 9:		//Tab
			{
			
				break;
			}
		
			case 224:	//Up Down
			{
				Input = getch();
				if (Input == 72)
				{
					if (Left(Dict, Curr) != NULL)
						Curr = Left(Dict, Curr);
				}
				else if (Input == 80)
				{
					if (Right(Dict, Curr) != NULL)
						Curr = Right(Dict, Curr);
				}
				break;
			}
		
			case 27:	//Esc
			{
				if(Confirm(Input))
					return;
				else
					system("cls");
				break;
			}
		
			default:
			{
				if((Input < 123 && Input > 96) || (Input < 91 && Input > 64) || Input == 32 || Input == 39 || Input == 45)
				{
					changed = true;
					Text += char(Input);
					Count++;
					gotoxy(BoxX + 12, BoxY + 1);
					if (Count < BoxS - 12)
					{
						cout << Text;
						for (int i = 0; i< BoxS - 11 - Count; i++)	cout << " ";
					}
					else
					{
						for (int i = Count - (BoxS - 12); i<Count; i++)	cout << Text[i];
					}
				}
			}
		
		}
	}
	
}


int main() 
{
	HTable *Dict = new HTable[26];
	
	for (int i = 0; i < 26; i++) 
	{
		Dict[i].Head = NULL;
		Dict[i].Tail = NULL;
	}
	ReadFile(Dict);
	
	NODEWORD *Curr = NULL;
	FindFirst(Dict,Curr);
	
	SearchBox(Dict,Curr);
//	for(int i=0; i<26; i++)
//	{
//		if(tudien[i].Head != NULL && tudien[i].Tail != NULL)
//		{
//			cout<<tudien[i].Head->data.This<<"\t"<<tudien[i].Tail->data.This<<endl;
//			cout<<tudien[i].Head->data.Type<<"\t"<<tudien[i].Tail->data.Type<<endl;
//			cout<<tudien[i].Head->data.First->data<<"\t"<<tudien[i].Tail->data.First->data<<"\n\n\n";
//		}
//	}
	
	
	return 0;
}
